       	       	    +---------------------------+
		    |		CS 140		|
		    | PROJECT 3: VIRTUAL MEMORY	|
		    |	   DESIGN DOCUMENT	|
		    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct block *swap_block;    /* Pointer to struct block representing swap space */
struct bitmap *swap_bitmap;  /* Bitmap which holds bits = block_size (swap_block)/bitmap_to_sector, 
                                where bitmap_to_sector=PGSIZE/BLOCK_SECTOR_SIZE */
uint32_t bitmap_to_sector;   /* This gives number of swap index needed to make a page */
struct lock swap_lock;       /* Lock when using swap_block */

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

We maintain a frame_table which is a list of frames in use. Everytime we try to find a frame,
we call palloc_get_page(PAL_USER) and add it to frame_table. Only when palloc fails, eviction kicks in.

We maintain a clock_hand pointer which points to an element in frame_table. On initialization, clock_hand is NULL.
Everytime we insert a frame from palloc, we insert it next to current clock_hand and move the clock_hand to point to inserted element.
Eg: Trying to insert [F1] to [H]->[F0]->[T], clock_hand = [F0] 
    After insertion:         [H]->[F0]->[F1]->[T], clock_hand = [F1] 

When we release a user virtual address and if a frame is servicing it, we return the frame to user_pool.
If clock_hand points to the frame to remove, move clock_hand to previous element/frame.
Eg:  If clock_hand == the element to remove 
     [H]->[F0]->[F1]->[F2]->[T] , clock_hand = [F1] ---(point to next)---> clock_hand = [F0]
     [H]->[F0]->[F1]->[F2]->[T] , clock_hand = [F0] ---(wrap around)---> clock_hand = [F2]
  
Coming to the actual frame choosen during eviction, we start from element to next of clock_hand(From the insertion example above, we
would start from [F0] thus implementing LRU) and go through the list in forward direction similar to "clocking".
If we find a frame which was accessed, we mark it as unaccessed for potentially picking it during 2nd run. If we find a 
unaccessed and unpinned frame, we pick it for eviction. Picked frame, if dirty, will write to swap slot or file. 

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

When we choose a frame to evict, the frame table entry has pointer to supplementry page_table entry and thread pointer of user virtual address associated with Q. 
We use pagedir_clear_page() to clear Q's user vaddr from page tables. Then we update the frame table entry to point to spte of P's user vaddr and update the thread pointer to that of P. By doing this, we have no frames associated with Q's evicted user vaddr and access to Q's evicted user vaddr would cause a page fault.   


>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

Synchronization is done with the following locks.
[1] A frame_table lock(Coarse lock).
[2] One lock per supplementry page table entry (Fine lock).
[3] Swap lock.(Coarse lock).
[4] File lock.(Coarse lock).

We prevent deadlock by ordering lock resources. 
[1] When a thread has to obtain multiple locks, 
     - frame_table lock would be the first acquired.
     - supplemetry table entry lock would be the next to be acquired.
     - filesys_lock and swap_lock cannot be held at the same time and they are the last to be acquired.

This ordering of locks prevents deadlock.

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

For any access/update to frame_table or for calling palloc_get_page(PAL_USER) on a page_fault, frame_table lock has to be obtained. 
So when P is in the process of eviting Q's frame, it would be holding the frame_table lock.
When the eviction logic picks Q's frame, it would first clear the page table entry corresponding to Q's user vaddr.
So if Q tries access or modify the page, it would page_fault. When Q page_faults it would try to acquire frame_table lock first. 
But the lock cannot be obtained till P's page fault is serviced completly. So when Q faults the page back in,
P would have gotten its page fault serviced completly thus preventing races.

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

Whenever Process P's user vaddr page faults, we first pin the user vaddr. The pinned/unpinned information is
stored in supplementry page table. The user vaddr is unpinned only after it gets a frame and required data is
read from file/swap or zeroed. So second process Q cannot interfere because whenever it tries to evict the frame which  
was assigned to P, it would read from spte(frame has pointer to spte it is currently assigned to) that the user vaddr
 is pinned. So the frame cannot be evicted.

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

In the syscalls we implement, the user vaddr of concern are the following
[1] command_line in SYS_EXEC.
[2] file_name in SYS_CREATE, SYS_REMOVE and SYS_OPEN.
[3] buffer in SYS_READ and SYS_WRITE.

We dont want them to page_fault inside filesys operations because the thread would acquire filesys_lock and
pagefault inside would cause deadlock because page_fault logic could cause read/write to file which needs the lock
aswel and cause deadlock. 

To avoid this, inside syscall_handler(), right before calling the separate syscalls mentioned above, 
[1] We pin the user vaddr mentioned above.
[2] If the user vaddrs have no page table entry, gracefully allocate frames to these user pages and create an entry in page table.
By pinning the user vaddr, we prevent the pages form getting evicted from the time we brought the frame and
the time we access it after holding filesys_lock.
After we come out of the syscall functions, we unpin the user vaddrs.

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

The three high level locks in VM systems are frame_table lock, swap_lock and supplementry page table entry lock.
They are for the entrire frame_table, swap space and per supplementry page table entry respectively. 

The reason for choosing a single frame_table lock than going for lock every frame_table
entry is because our frame_table structure has a list and clock_hand pointer which are common
to all processes. So multiple locks for frame_table will be complicated.

Also introducing a swap_lock helps us parallelise read from swap_slot and frame allocation/eviction process.
So when a frame is reading from swap slot another page_fault could be serviced(As mentioned above the frame can't
be evicetd because of pinning).

Supplementry page table entry has variables named pinned, page type(whether it from file/swap) etc.
Lets take a process P which has a supplementry page table entry for a user vaddr. The above variables of the supplementry
page table entry can be updated by process P and it can be read by other Processes during eviction(We need to know if a frame
is pinned or not). By creating separate locks per entry, reading and writing of different entries are parallel.

By these 3 high level locks we create parallelism but we don't overdo it and complicate our design.


			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
